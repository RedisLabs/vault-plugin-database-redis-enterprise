package plugin

import (
	"context"
	"fmt"

	"github.com/RedisLabs/vault-plugin-database-redisenterprise/internal/sdk"
	"github.com/hashicorp/vault/sdk/database/dbplugin/v5"
)

// DeleteUser removes a user from the cluster entirely
func (r *RedisEnterpriseDB) DeleteUser(ctx context.Context, req dbplugin.DeleteUserRequest) (dbplugin.DeleteUserResponse, error) {
	user, err := r.client.FindUserByName(ctx, req.Username)

	if err != nil {
		if _, ok := err.(*sdk.UserNotFoundError); ok {
			// If the user is not found, they may have been deleted manually. We'll assume
			// this is okay and return successfully.
			return dbplugin.DeleteUserResponse{}, nil
		}
		return dbplugin.DeleteUserResponse{}, err
	}

	r.logger.Debug("delete user", "username", req.Username, "uid", user.UID)

	if err := r.client.DeleteUser(ctx, user.UID); err != nil {
		return dbplugin.DeleteUserResponse{}, fmt.Errorf("cannot delete user %s: %w", req.Username, err)
	}

	if r.config.hasDatabase() {
		client := r.simpleClient
		// If we have a database we need to there may be a generated
		// role. If we find the generated role by name, we must also delete
		// the generated role binding

		// Find the role id of the potentially generated role
		role := r.config.Database + "-" + req.Username
		rid, _, generatedRole, err := findRole(*client, role)
		if err != nil {
			return dbplugin.DeleteUserResponse{}, fmt.Errorf("cannot get roles: %w", err)
		}

		// If we found a role with the name, it was generated by this plugin
		if generatedRole {

			// We must:
			// 1. Retrieve the DB and role ids
			// 2. Find the role binding in roles_permissions in the DB definition
			// 4. Remove the role binding
			// 3. Delete the role

			// Get the database id
			dbid, found, err := findDatabase(*client, r.config.Database)
			if err != nil {
				return dbplugin.DeleteUserResponse{}, fmt.Errorf("cannot get databases: %s", err)
			}
			if !found {
				return dbplugin.DeleteUserResponse{}, fmt.Errorf("cannot find database: %s", r.config.Database)
			}

			// Get the database information
			var v interface{}
			err = client.get(fmt.Sprintf("/v1/bdbs/%.0f", dbid), &v)
			if err != nil {
				return dbplugin.DeleteUserResponse{}, fmt.Errorf("cannot get database info: %s", err)
			}

			// Find the role binding to ACL
			rolesPermissions, found := v.(map[string]interface{})["roles_permissions"].([]interface{})
			if !found {
				return dbplugin.DeleteUserResponse{}, fmt.Errorf("database information has no 'roles_permissions': %s", r.config.Database)
			}
			found_acl := false
			var position int
			for index, value := range rolesPermissions {
				binding := value.(map[string]interface{})
				brole, found := binding["role_uid"]
				if !found {
					continue
				}
				if rid == brole {
					position = index
					found_acl = true
					break
				}
			}

			// If there is a role binding, we must remove the target role
			if found_acl {

				// Remove the binding
				rolesPermissions = append(rolesPermissions[:position], rolesPermissions[position+1:]...)

				// Update the database
				err = updateRolePermissions(*client, dbid, rolesPermissions)
				if err != nil {

					// Attempt to delete the generated role - we know this may fail
					err = client.delete(fmt.Sprintf("/v1/roles/%.0f", rid))
					return dbplugin.DeleteUserResponse{}, fmt.Errorf("user deleted but role and role binding cannot be removed - cannot update role_permissions in database %s: %s", r.config.Database, err)
				}

			}

			// Delete the generated role
			err = client.delete(fmt.Sprintf("/v1/roles/%.0f", rid))
			if err != nil {
				return dbplugin.DeleteUserResponse{}, fmt.Errorf("cannot delete role (%s,%.0f): %s", role, rid, err)
			}

		}

	}
	return dbplugin.DeleteUserResponse{}, nil
}
